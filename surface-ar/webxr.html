<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Surface AR – WebXR Hit-Test (mit Animation)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui}
  #enter{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:12px;border:1px solid #555;background:#111;color:#fff}
  #msg{position:fixed;left:12px;bottom:12px;opacity:.9}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';

let camera, scene, renderer, reticle, controller, hitTestSource=null, hitTestSourceRequested=false;
let model=null, mixer=null, clips=[];
const clock = new THREE.Clock();

const qs = new URLSearchParams(location.search);
const sceneUrl = qs.get('scene');

const cfg = {
  modelUrl: 'https://modelviewer.dev/shared-assets/models/Astronaut.glb',
  position: [0,0,0], rotation: [0,0,0], scale:[0.6,0.6,0.6],
  animation: '*'
};

async function loadScene(){
  if (!sceneUrl) return;
  const r = await fetch(sceneUrl, {cache:'no-cache'}); if(!r.ok) throw new Error('scene.json Load '+r.status);
  const j = await r.json();
  if (j?.model?.url) cfg.modelUrl = j.model.url;
  if (Array.isArray(j?.model?.position)) cfg.position = j.model.position;
  if (Array.isArray(j?.model?.rotation)) cfg.rotation = j.model.rotation;
  if (Array.isArray(j?.model?.scale))    cfg.scale    = j.model.scale;
  if (j?.model?.animation!=null)         cfg.animation= j.model.animation;
}

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(0,6,0); scene.add(dir);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // Reticle
  const ring = new THREE.RingGeometry(0.07, 0.08, 32).rotateX(-Math.PI/2);
  const mat = new THREE.MeshBasicMaterial({color:0x66ccff});
  reticle = new THREE.Mesh(ring, mat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  addEventListener('resize', ()=>renderer.setSize(innerWidth, innerHeight));

  document.getElementById('enter').addEventListener('click', startAR);
}

function playClips(){
  if (!mixer || !clips.length) return;
  const a = cfg.animation;
  if (a==='none') return;
  if (a==='*'){
    clips.forEach(c=>mixer.clipAction(c).play());
  } else if (typeof a==='string'){
    const c = clips.find(c=>c.name===a) || clips[0]; mixer.clipAction(c).play();
  } else {
    const idx = Math.max(0, Math.min(clips.length-1, parseInt(a||0,10))); mixer.clipAction(clips[idx]).play();
  }
}

function onSelect() {
  if (!reticle.visible) return;
  if (!model) {
    const loader = new GLTFLoader();
    loader.load(cfg.modelUrl, (gltf) => {
      model = gltf.scene;
      const [sx,sy,sz]=cfg.scale; model.scale.set(sx,sy,sz);
      const [rx,ry,rz]=cfg.rotation; model.rotation.set(THREE.MathUtils.degToRad(rx), THREE.MathUtils.degToRad(ry), THREE.MathUtils.degToRad(rz));
      model.position.setFromMatrixPosition(reticle.matrix);
      scene.add(model);
      clips = gltf.animations||[];
      if (clips.length){ mixer = new THREE.AnimationMixer(model); playClips(); }
    });
  } else {
    model.position.setFromMatrixPosition(reticle.matrix);
  }
}

async function startAR(){
  if (!navigator.xr) return alert('WebXR nicht verfügbar.');
  const isARSupported = await navigator.xr.isSessionSupported('immersive-ar');
  if (!isARSupported) return alert('Dein Gerät/Browser unterstützt kein WebXR-AR.');
  const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test','local-floor'] });
  renderer.xr.setReferenceSpaceType('local-floor');
  await renderer.xr.setSession(session);
  document.getElementById('enter').style.display='none';
  animate();
}

function animate() { renderer.setAnimationLoop(render); }

function render(t, frame) {
  const dt = clock.getDelta(); if (mixer) mixer.update(dt);
  if (!frame){ renderer.render(scene, camera); return; }
  const referenceSpace = renderer.xr.getReferenceSpace();
  const session = renderer.xr.getSession();

  if (!hitTestSourceRequested) {
    session.requestReferenceSpace('viewer').then((viewerSpace) => {
      session.requestHitTestSource({ space: viewerSpace }).then((source) => { hitTestSource = source; });
    });
    session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
    hitTestSourceRequested = true;
  }

  if (hitTestSource) {
    const results = frame.getHitTestResults(hitTestSource);
    if (results.length) {
      const hit = results[0];
      const pose = hit.getPose(referenceSpace);
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
    } else { reticle.visible = false; }
  }

  renderer.render(scene, camera);
}

(async ()=>{ try{ await loadScene(); }catch(e){ console.warn(e); } init(); })();
</script>
</head>
<body>
  <button id="enter">Start AR</button>
  <div id="msg">Android Chrome empfohlen · Tippe auf den Boden, um das Modell zu platzieren</div>
</body>
</html>
