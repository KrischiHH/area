<script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  const loader = new GLTFLoader();
  loader.setCrossOrigin('anonymous');

  const scene = window.scene || new THREE.Scene();
  let modelRoot = new THREE.Group();
  scene.add(modelRoot);

  function disposeObject3D(root){
    root.traverse(n=>{
      if(n.isMesh){
        n.geometry?.dispose?.();
        const mats = Array.isArray(n.material) ? n.material : [n.material];
        mats.forEach(m=>{
          if(!m) return;
          ['map','normalMap','metalnessMap','roughnessMap','emissiveMap','aoMap','alphaMap','envMap','specularMap','bumpMap','displacementMap']
            .forEach(k => m[k]?.dispose?.());
          m.dispose?.();
        });
      }
    });
  }
  function clearModel(){ modelRoot.children.forEach(c=>disposeObject3D(c)); modelRoot.clear(); }
  function applyTransform(group, t={}){
    group.position.set(+t.px||0, +t.py||0, +t.pz||0);
    group.rotation.set(+t.rx||0, +t.ry||0, +t.rz||0);
    group.scale.set(+t.sx||1, +t.sy||1, +t.sz||1);
  }
  async function loadGLBFromURL(glbURL, transform){
    return new Promise((resolve,reject)=>{
      loader.load(glbURL, (gltf)=>{
        clearModel();
        const root = gltf.scene || gltf.scenes?.[0];
        modelRoot.add(root);
        applyTransform(modelRoot, transform);
        resolve(root);
      }, undefined, reject);
    });
  }

  // OPTIONAL: Falls du im Image-Viewer eine Funktion/Variable fÃ¼r das Target hast:
  // Implementiere diese zwei Zeilen in deiner MindAR/AR.js-Initialisierung:
  // window.setImageTargetUrl = (url)=>{ /* hier dein Target (.mind) zuweisen */ };

  const TARGET_ORIGIN = location.origin;
  try { window.opener && window.opener.postMessage({ type:'webar-ready' }, TARGET_ORIGIN); } catch {}

  window.addEventListener('message', async (e)=>{
    if (e.origin !== TARGET_ORIGIN) return;
    const msg = e.data || {};
    if (msg.type !== 'webar-load') return;

    try{
      if (msg.mode === 'image' && msg.target && typeof window.setImageTargetUrl === 'function'){
        window.setImageTargetUrl(msg.target);
      }
      const blob = new Blob([msg.glbBuffer], { type:'model/gltf-binary' });
      const url  = URL.createObjectURL(blob);
      await loadGLBFromURL(url, msg.transform || {});
      setTimeout(()=> URL.revokeObjectURL(url), 30000);
      console.log('[image-viewer] Modell per postMessage geladen');
    }catch(err){
      console.error('[image-viewer] Laden fehlgeschlagen', err);
    }
  });

  // Fallback via Query
  (async function(){
    const q = new URLSearchParams(location.search);
    const glb = q.get('glb');
    if (!glb) return;
    if (q.get('target') && typeof window.setImageTargetUrl === 'function'){
      window.setImageTargetUrl(q.get('target'));
    }
    const transform = {
      px:+q.get('px')||0, py:+q.get('py')||0, pz:+q.get('pz')||0,
      rx:+q.get('rx')||0, ry:+q.get('ry')||0, rz:+q.get('rz')||0,
      sx:+q.get('sx')||1, sy:+q.get('sy')||1, sz:+q.get('sz')||1,
    };
    try{
      await loadGLBFromURL(glb, transform);
      console.log('[image-viewer] Modell aus Query geladen');
    }catch(err){
      console.error('[image-viewer] Query-Laden fehlgeschlagen', err);
    }
  })();
</script>
